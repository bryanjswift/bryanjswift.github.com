---
layout: post
title: functional programming ftw
---

<p><a href="http://blog.harryh.org/post/167384715/functional-programming-ftw" class="tumblr_blog">harryh</a>:</p>



<blockquote><p>Simple, but fun:</p>

<pre>def partition[T](items: List[T], p: (T, T) =&gt; Boolean): List[List[T]] = {

  items.foldRight[List[List[T]]](Nil)((item: T, items: List[List[T]]) =&gt; items match {

    case (first :: rest) :: last if p (first, item) =&gt;

      (List(item)) :: (first :: rest) :: last

    case (first :: rest) :: last =&gt;

      (item :: first :: rest) :: last

    case _ =&gt; List(List(item))

  })

}</pre>

<p>If you understand what this does, or know someone who does, Iâ€™m hiring.  Send me an e-mail.</p></blockquote>



<p>It took me a bit but I did sort this out. I like Scala and how it lets you express powerful things concisely but I have to give my brain time parse stuff like this still.</p>
